# Results
Our graph consists of vertices containing information about each actor/director who worked on shows on Netflix. Edges are formed where two actors/directors worked on the same movie/show. 
## BFS
When implementing the operator “++” for the iterator, it is important to make sure all connected components are visited. So that means even though when the queue is empty, it is still needed to loop through the vector “visited” to determine if all vertices have been visited. If one element of “visited” is false, we can add to queue that vertex, which can be accessed by using the same index in the vector “vertices”. The process of determining if all vertices are visited are not very time-efficient because every time we finish visiting one connected component, we need to do that process, but I was not able to find a better way to do this.

Another interesting finding is that the BFS class has some variables like “current”, “start”, and “traversal”, which are stored in heap. And if I try to delete them in the destructor, the SIGABRT error would be raised.  I guess it is because I have already deleted every vertex in the destructor of NetflixGraph, so I do not need to delete again in traversal.
## Dijkstra
The Dijkstra function allows the user to input two actors’ or directors’ names and outputs the shortest path between them and the length of said path. It holds a map of the distances to each vertex from the first actor the user inputs. The distances start out initialized to int_max and are updated whenever a shorter distance is found. The algorithm had to be rewritten multiple times first to make it more efficient and then changing the output method to make writing tests easier and to work with the variable output format in main. 
## All Paths
Writing the all paths algorithm for small scale test data was simple -- use a while loop to implement a BFS, and whenever the target actor is found, add the path to a vector of paths and return. However, when the data was scaled up we ran into some issues. As the algorithm found more and more increasingly complex paths, the vector would never be returned as the algorithm found permutations of previously found paths. To solve this, we reworked the algorithm to print out paths as it found them, and allowed the user to specify a maximum path size.

During testing, we ran into some issues with edge cases. Blank cast member values and invalid inputs were fixed by performing checks for valid paths at the beginning of findpaths(). The algorithm also helped us find paths that we wouldn’t have thought to look for. For example, in tests/data/tests_3.json, Jerry Seinfeld to Claude Monet is three paths, since it can traverse Jerry -> Jeff -> Orange -> Claude. These unintuitive extra steps tripped us up a lot; the nature of this algorithm is what made it so inefficient.
